description = "Analyze a ticket and generate an implementation plan in Obsidian"
prompt = """
# Implementation Plan Analysis: {{args}}

## HARD CONSTRAINTS (NON-NEGOTIABLE)

- **NO CODE WRITING** — Do not write, edit, or modify any code. This is analysis only.
- **NO IMPLEMENTATION** — Do not implement features, fix bugs, or make changes.
- **DO NOT CALL submit_plan** — Save the plan to Obsidian, do not trigger interactive plan review.
- **ANALYSIS OUTPUT ONLY** — Your deliverable is a written plan, nothing else.
- **USE OBSIDIAN FOR PLANS** — Plans MUST be saved using the Obsidian MCP tools (`obsidian_append_note`). Do NOT use `write` or `edit` tools to save plans to the local filesystem.

If you find yourself wanting to write code, STOP. Your job is to produce a plan for `/implement` to execute.

---

## Prerequisites

Fetch the ticket details in full (JSON preferred) before proceeding:
- For beads: `bd show {{args}} --json`

---

## Step 1: Scope Check (GATE)

After fetching the ticket, determine its type and scope:

1. **Check if Epic:** Does it have child tickets/stories?
2. **Count children:** How many child tickets exist?

### Scope Guard

| Condition | Action |
| --------- | ------ |
| **Single ticket (story/task)** | Proceed with analysis |
| **Epic with 1-3 children** | Proceed — manageable scope |
| **Epic with 4+ children** | **STOP** — Scope too large |

**If scope is too large:**
```
⚠️ SCOPE TOO LARGE

This epic has [N] child tickets. Analyzing all of them will produce an unwieldy plan.

Recommendation: Run `/analyze` on individual stories instead:
- [list child ticket IDs]

Would you like to proceed with a specific story, or continue with the full epic analysis anyway?
```

Wait for user confirmation before proceeding with large epics.

---

## Step 2: Codebase Research

Research the implementation context for each ticket in scope:

- Find relevant code locations
- Identify affected components
- Map dependencies and interfaces
- Note existing patterns to follow

**While researching, determine:**
- Implementation order based on dependencies
- Parallelization opportunities (which tickets can run concurrently)
- Shared concerns across tickets

---

## Step 3: Implementation Mapping

For each ticket, identify:

- Specific files to modify
- Functions/components to create or change
- Data model or schema changes
- Test files to add or update
- Verification approach

---

## Step 4: Output - Implementation Plan

Produce a structured implementation plan that `/implement` can execute.

### Plan Template

```markdown
# Implementation Plan: {{args}}

**Generated:** <timestamp>
**Ticket:** <title>
**Type:** Epic | Story | Task

## Executive Summary

[2-3 sentences: scope, approach, key decisions]

## Tickets in Scope

| ID  | Title | Status | Dependencies | Parallelizable |
| --- | ----- | ------ | ------------ | -------------- |
| ... | ...   | ...    | ...          | Yes/No         |

## Implementation Phases

### Phase 1: <name>

**Tickets:** <list of ticket IDs that can run in parallel>

#### Ticket <ID>: <title>

- **Work:**
  - [ ] <specific action>
  - [ ] <specific action>
- **Files:** <key files to modify>
- **Verification:** <how to verify completion>

### Phase 2: <name>

**Depends on:** Phase 1

[Continue for all phases]

## Parallel Execution Plan

```
Phase 1: [TICKET-1, TICKET-2] (parallel)
    |
    v
Phase 2: [TICKET-3] (depends on Phase 1)
    |
    v
Phase 3: [TICKET-4, TICKET-5, TICKET-6] (parallel)
```

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
| ---- | ---------- | ------ | ---------- |
| ...  | ...        | ...    | ...        |

## Discovered Gaps

If implementation analysis reveals missing prerequisites or undefined work:

| Gap | Description | Recommendation                                |
| --- | ----------- | --------------------------------------------- |
| ... | ...         | Run /story, create task, or proceed with risk |

**Note:** Gaps are blockers. Resolve before running /implement or acknowledge the risk.
```

---

## Step 5: Save Plan (MANDATORY)

Save the implementation plan to Obsidian using the Obsidian MCP tools.

**Required tool:** `obsidian_append_note`
**Path:** `{{BEADS_PLAN_DIR or "working/plans"}}/{{args}}-plan.md`

```
obsidian_append_note(
  filepath: "{{BEADS_PLAN_DIR or "working/plans"}}/{{args}}-plan.md",
  content: <full plan content>
)
```

⚠️ **DO NOT use `write` or `edit` tools** — these write to the local filesystem, not Obsidian.

If the Obsidian write fails:
1. Report the error to the user
2. Output the full plan in the chat as a fallback
3. Ask the user to manually save or retry

---

## Quality Checklist

Before finalizing the plan:

- [ ] Scope check passed (or user approved large epic)
- [ ] All tickets in scope are accounted for
- [ ] Dependencies are correctly mapped
- [ ] Parallelization opportunities identified
- [ ] Each ticket has specific file/code changes identified
- [ ] Verification criteria defined for each ticket
- [ ] Risks identified with mitigations
- [ ] Gaps flagged (if any)
- [ ] Plan saved to Obsidian via `obsidian_append_note` (NOT local filesystem)
- [ ] **No code was written during this process**

---

## Begin Analysis

Now analyze ticket: **{{args}}**

Start with Step 1: Fetch the ticket and perform scope check.

**DO NOT IMPLEMENT ANY CODE** — Your output is a plan document, not working software.
"""
